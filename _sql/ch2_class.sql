### sqldb 생성 시작 ###

# 1. database 생성 !! 
# 기존에 db가 있는지 없는지 체크
DROP DATABASE IF EXISTS SQLDB;
CREATE DATABASE SQLDB;

# 2. TABLE 만들기
USE SQLDB;
# USERTBL 생성
CREATE TABLE USERTBL (
	USERID		CHAR(8)		NOT NULL	PRIMARY KEY,
    NAME		VARCHAR(10)	NOT NULL,
    BIRTHYEAR	INT			NOT NULL,
    ADDR		CHAR(2)		NOT NULL, 	-- 지역(경기, 서울, 경남 두글자만)
    MOBILE1		CHAR(3)		NULL,		-- 휴대폰 번호 국번
    MOBILE2		CHAR(8)		NULL,		-- 휴대폰 뒤 8자리
    HEIGHT		SMALLINT	NULL,		-- 키에 대한 정보
    MDATE		DATE		NULL		-- 회원 가입일
);
SELECT * FROM USERTBL;
# BUYTBL 생성
CREATE TABLE BUYTBL(
	NUM			INT			NOT NULL	AUTO_INCREMENT		PRIMARY KEY,
    USERID		CHAR(8)		NOT	NULL,
    PRODNAME	CHAR(6)		NOT NULL,
    GROUPNAME	CHAR(4)		NULL,
    PRICE		INT			NOT NULL,
    AMOUNT		SMALLINT	NOT NULL,
    FOREIGN KEY (USERID) REFERENCES USERTBL(USERID)
);
SELECT * FROM BUYTBL;
# 데이터 입력
INSERT INTO usertbl VALUES('LSG', '이승기', 1987, '서울', '011', '1111111', 182, '2008-8-8');
INSERT INTO usertbl VALUES('KBS', '김범수', 1979, '경남', '011', '2222222', 173, '2012-4-4');
INSERT INTO usertbl VALUES('KKH', '김경호', 1971, '전남', '019', '3333333', 177, '2007-7-7');
INSERT INTO usertbl VALUES('JYP', '조용필', 1950, '경기', '011', '4444444', 166, '2009-4-4');
INSERT INTO usertbl VALUES('SSK', '성시경', 1979, '서울', NULL  , NULL      , 186, '2013-12-12');
INSERT INTO usertbl VALUES('LJB', '임재범', 1963, '서울', '016', '6666666', 182, '2009-9-9');
INSERT INTO usertbl VALUES('YJS', '윤종신', 1969, '경남', NULL  , NULL      , 170, '2005-5-5');
INSERT INTO usertbl VALUES('EJW', '은지원', 1972, '경북', '011', '8888888', 174, '2014-3-3');
INSERT INTO usertbl VALUES('JKW', '조관우', 1965, '경기', '018', '9999999', 172, '2010-10-10');
INSERT INTO usertbl VALUES('BBK', '바비킴', 1973, '서울', '010', '0000000', 176, '2013-5-5');

INSERT INTO buytbl VALUES(NULL, 'KBS', '운동화', NULL   , 30,   2);
INSERT INTO buytbl VALUES(NULL, 'KBS', '노트북', '전자', 1000, 1);
INSERT INTO buytbl VALUES(NULL, 'JYP', '모니터', '전자', 200,  1);
INSERT INTO buytbl VALUES(NULL, 'BBK', '모니터', '전자', 200,  5);
INSERT INTO buytbl VALUES(NULL, 'KBS', '청바지', '의류', 50,   3);
INSERT INTO buytbl VALUES(NULL, 'BBK', '메모리', '전자', 80,  10);
INSERT INTO buytbl VALUES(NULL, 'SSK', '책'    , '서적', 15,   5);
INSERT INTO buytbl VALUES(NULL, 'EJW', '책'    , '서적', 15,   2);
INSERT INTO buytbl VALUES(NULL, 'EJW', '청바지', '의류', 50,   1);
INSERT INTO buytbl VALUES(NULL, 'BBK', '운동화', NULL   , 30,   2);
INSERT INTO buytbl VALUES(NULL, 'EJW', '책'    , '서적', 15,   1);

SELECT * FROM BUYTBL;
SELECT * FROM USERTBL;

# 그러면 이렇게 있는 자료 조회
# ex) 이름이 김경호인 사람의 모든 정보
SELECT * FROM USERTBL WHERE NAME = '김경호';

# examples
SELECT * FROM USERTBL WHERE NAME = '김범수';
SELECT * FROM USERTBL WHERE NAME = '조관우';
SELECT * FROM USERTBL WHERE ADDR = '서울';
SELECT * FROM USERTBL WHERE BIRTHYEAR = 1973;
SELECT * FROM USERTBL WHERE MOBILE1 IS NULL; -- if mobile1 value is null show 
SELECT * FROM USERTBL WHERE MOBILE1 IS NOT NULL; -- IF MOBILE1 VALUE IS NOT NULL SHOW

# SELECT 문
# EX) BIRTHYEAR 1970 이상, HEIGHT 183 이상
SELECT * FROM USERTBL WHERE BIRTHYEAR >= 1970 AND HEIGHT >= 183;

# examples
SELECT * FROM USERTBL WHERE BIRTHYEAR >= 1970 AND HEIGHT >= 182;
SELECT USERID,NAME FROM USERTBL WHERE BIRTHYEAR >= 1970 AND HEIGHT >= 182;
SELECT * FROM USERTBL WHERE ADDR = '서울' AND MOBILE1 = 011;
SELECT USERID, MOBILE1, MOBILE2 FROM USERTBL WHERE ADDR = '서울' AND MOBILE1 = 011;

SELECT USERID, CONCAT(MOBILE1,"-",MOBILE2) AS PHONE FROM USERTBL WHERE ADDR = '서울' AND MOBILE1 = 011;
-- 인상적인 CONCAT의 활용 

## 키가 180~183 사이
# 조건표현 ) 키 180이상 and 키183 이하 -> 180 <= HEIGHT AND HIEGHT <= 183
# 조건표현 ) 키 180이상 and 키183 이하 -> BETWEEN ~ AND ~
SELECT NAME,HEIGHT FROM USERTBL WHERE (180 <= HEIGHT) AND (HEIGHT <= 183);
SELECT NAME, HEIGHT FROM USERTBL WHERE HEIGHT BETWEEN 180 AND 183;

# DISCRETE 한 값을 조건
SELECT NAME, ADDR FROM USERTBL WHERE (ADDR = '경남') | (ADDR = '전남') | (ADDR = '경북');
SELECT NAME, ADDR FROM USERTBL WHERE ADDR IN ('경남','전남','경북');

# 정규식
SELECT NAME, HEIGHT FROM USERTBL WHERE NAME LIKE '김%'; --  % : 김~~~~ 무엇이든 허용
SELECT NAME, HEIGHT FROM USERTBL WHERE NAME LIKE '_지_'; -- _ : ~지~ 딱 _ 만큼 허용
SELECT NAME, HEIGHT FROM USERTBL WHERE NAME LIKE '_종신'; 
SELECT NAME, HEIGHT FROM USERTBL WHERE NAME LIKE '_용%'; 
# subquery

# 김경호보다 키가 크거나 같은 사람의 이름과 키 출력
SELECT NAME,HEIGHT FROM USERTBL
	WHERE HEIGHT >= (SELECT HEIGHT FROM USERTBL WHERE NAME='김경호')
	AND NAME != '김경호';

# 지역이 경기 경남 경북인 사람들의 이름 지역 키
SELECT NAME, ADDR, HEIGHT FROM USERTBL WHERE ADDR LIKE '경_';

# 지역이 경남인 사람의 키보다 큰 사람의 이름과 키
SELECT NAME,HEIGHT,ADDR FROM USERTBL
	WHERE HEIGHT >= ALL(SELECT  HEIGHT FROM USERTBL WHERE ADDR='경남')
    AND ADDR != '경남';
-- ALL HEIGHT가 경남의 모든 사람보다 커야함
-- ANY HEIGHT가 경남의 누군가 보다는 커야함

# any and in
SELECT NAME, HEIGHT FROM USERTBL
	WHERE HEIGHT = ANY(SELECT HEIGHT FROM USERTBL WHERE ADDR='경남');
SELECT NAME, HEIGHT FROM USERTBL
	WHERE HEIGHT IN (170,173);

# 정렬 orderby
SELECT * FROM USERTBL LIMIT 1;
SELECT NAME,HEIGHT,MDATE FROM USERTBL ORDER BY HEIGHT; -- DEFAULT ASC
SELECT NAME,HEIGHT,MDATE FROM USERTBL ORDER BY HEIGHT ASC; 
SELECT NAME,HEIGHT,MDATE FROM USERTBL ORDER BY HEIGHT DESC;
SELECT NAME,HEIGHT,MDATE FROM USERTBL ORDER BY HEIGHT DESC, NAME ASC;

# 회원정보 테이블에서 가입한 날짜 순서대로 
# 신규 회원
SELECT * FROM USERTBL ORDER BY MDATE DESC;
# 초기 회원
SELECT * FROM USERTBL ORDER BY MDATE ASC;

# distinct -> 중복될 때 처리
SELECT ADDR FROM USERTBL;
SELECT ADDR FROM USERTBL ORDER BY ADDR;
SELECT DISTINCT ADDR FROM USERTBL ORDER BY ADDR;

# 조회된 결과가 너무 많아서 일부만 보자
# db 변경 중복이 많은 걸로
USE EMPLOYEES;
# EMPLOYEE 테이블에서 emp_no hire_date만 보자
# 단 입사일을 기준으로 초기 사원부터 
SELECT DISTINCT HIRE_DATE, EMP_NO FROM EMPLOYEES ORDER BY HIRE_DATE ASC;
SELECT HIRE_DATE, EMP_NO FROM EMPLOYEES ORDER BY HIRE_DATE ASC;

SELECT * FROM EMPLOYEES LIMIT 1;
SELECT EMP_NO, CONCAT(FIRST_NAME,'_',LAST_NAME) AS NAME, HIRE_DATE 
	FROM EMPLOYEES ORDER BY HIRE_DATE DESC LIMIT 10;

# 테이블을 복사하는 CREATE TABLE ... SELECT
# CREATE TABLE NEW_TABLE (SELECT * FROM CURRENT_TABLE);
USE SQLDB;
# BUYTBL -> BUYTBL2로 복사
CREATE TABLE BUYTBL2 (SELECT * FROM BUYTBL);

DESC BUYTBL;
DESC BUYTBL2;

## GROUP BY 및 HAVING 집계함수
USE SQLDB;
SELECT USERID, AMOUNT FROM BUYTBL ORDER BY USERID;
SELECT USERID,SUM(AMOUNT) FROM BUYTBL GROUP BY USERID;
SELECT USERID, SUM(AMOUNT) FROM BUYTBL GROUP BY USERID ORDER BY USERID;

SELECT USERID,SUM(AMOUNT) AS '총구매수량' FROM BUYTBL GROUP BY USERID;
SELECT USERID,AVG(AMOUNT) AS '평균구매수량' FROM BUYTBL GROUP BY USERID;
SELECT SUM(AMOUNT) FROM BUYTBL;

# 고객별로 구매한 총 수량에 대해서 내림차순으로 봤을 때, top3
SELECT 
    USERID, SUM(AMOUNT) AS '총합'
FROM
    BUYTBL
GROUP BY USERID
ORDER BY 총합 DESC
LIMIT 3;

SELECT 
    USERID AS '고객아이디', SUM(AMOUNT) AS '총합'
FROM
    BUYTBL
GROUP BY USERID
ORDER BY 총합 DESC
LIMIT 3;

select * from buytbl;

# 회원별 총 소비금액
SELECT USERID, SUM(PRICE*AMOUNT) AS TOTAL 
	FROM BUYTBL 
    GROUP BY USERID 
    ORDER BY TOTAL DESC
	LIMIT 3
    ;

# 회원 정보 중에서 가장 큰키와 작은 키 
SELECT * FROM USERTBL LIMIT 1;
SELECT NAME, MIN(HEIGHT), MAX(HEIGHT) FROM USERTBL ;

# 서브 쿼리를 활용할 수 있다.
SELECT NAME, HEIGHT FROM USERTBL
	WHERE (HEIGHT = (SELECT MAX(HEIGHT) FROM USERTBL)) | (HEIGHT = (SELECT MIN(HEIGHT) FROM USERTBL))
    ORDER BY HEIGHT DESC;
    
### 그 조건에 맞는 데이터가 몇개인가
# ex usertbl에 데이터가 몇개인가
SELECT COUNT(*) FROM USERTBL;

# ex 전화 정보를 기록한 회원은 몇 명
SELECT COUNT(*) FROM USERTBL WHERE MOBILE1 IS NOT NULL;

### "HAVING"
# WHERE 과 비슷한 개념으로 조건 제한하는 것이지만, 집계 함수에 대해서 조건을 제한하는 것
# 사용자별 총 구매액
SELECT USERID, SUM(PRICE * AMOUNT) FROM BUYTBL GROUP BY USERID ;

# SELECT USERID, SUM(PRICE * AMOUNT) AS TOTAL FROM BUYTBL GROUP BY USERID WHERE TOTAL > 1000;
# -> 집계값에 대해 WHERE을 사용하면 ERROR가 발생한다.

SELECT USERID, SUM(PRICE * AMOUNT) AS TOTAL 
	FROM BUYTBL GROUP BY USERID 
    HAVING TOTAL > 1000
	ORDER BY TOTAL DESC
;

SELECT * FROM USERTBL LIMIT 1;
